# 面试题

## 反射的概念

### 反射的概念

在Java中，反射是指**在运行时动态地获取类的信息以及操作类或对象的能力**。它允许程序在运行时检查和操作其内部结构，比如类、接口、字段、方法等。

Java的反射功能由`java.lang.reflect`包提供支持。通过使用反射，可以在编译时未知的情况下，获取类的名称、父类、实现的接口、字段和方法的信息，并且可以在运行时创建对象、调用方法、访问和修改字段的值。

需要注意的是，反射是一种强大但复杂的技术，过度使用反射可能会导致代码可读性下降、性能降低，并增加调试和维护的难度。因此，在使用反射时应该谨慎，并权衡使用反射带来的好处和代价。

### 反射的优缺点

反射是Java中一项强大的特性，它允许程序在运行时检查和操作类、方法、字段等。

优点：

1. 动态性：反射使得程序可以在运行时动态地加载、查找和使用类。这为开发人员提供了更大的灵活性，可以根据需要处理不同类型的对象。
2. 运行时信息：通过反射，可以获取关于类、方法、字段等的详细信息，如名称、类型、修饰符等。这些信息对于编写通用代码、调试和日志记录非常有用。
3. 动态创建对象：利用反射，可以在运行时动态创建实例，而无需提前知道类的具体类型。这对于框架和库的开发非常有用，因为它们可以根据配置或条件创建适当的对象。
4. 动态调用方法：反射允许在运行时调用类的方法，甚至可以访问和修改私有方法。这对于编写泛型代码和执行特定操作非常有用。

缺点：

1. 性能影响：由于反射涉及到动态解析和调用，相比于直接调用方法或访问字段，它可能会引入较大的性能开销。反射操作通常比静态方法调用慢。
2. 安全性限制：反射可以绕过访问修饰符的限制，即使是私有成员也可以被访问和修改。这可能破坏了封装性和安全性，并且需要开发人员自己负责确保正确使用反射。
3. 可读性和维护性：由于反射允许在运行时动态调用和处理类，代码可能变得更加复杂和难以理解。它还增加了代码的依赖关系，使得重构和维护变得更加困难。

总结起来，反射是一项强大的特性，但在使用时需要考虑性能、安全性和可维护性等因素，并权衡其带来的好处和代价。

### 为什么需要反射，使用场景和作用

Java中需要反射的主要原因是为了增强程序的灵活性和动态性。下面是一些使用反射的常见情况：

1. 运行时类型检查和操作：反射使得程序可以在运行时检查和操作类、方法、字段等的信息。这对于编写通用代码或处理不确定类型的对象非常有用，例如框架和库的开发。
2. 动态创建对象：通过反射，可以在运行时动态地创建类的实例，而无需提前知道类的具体类型。这对于实现插件系统、依赖注入和配置驱动的应用程序非常有用。
3. 动态调用方法：反射允许在运行时动态地调用类的方法，包括私有方法。这对于实现回调机制、执行特定操作或在运行时根据条件选择适当的方法非常有用。
4. 获取类的元数据：通过反射，可以获取关于类、方法、字段等的详细信息，如名称、类型、修饰符等。这些信息对于编写通用代码、调试和日志记录非常有用。
5. 处理注解：反射可以用于处理注解，即在类、方法、字段等上附加的元数据。通过反射，可以读取注解并根据其提供的信息执行相应的逻辑。

虽然反射提供了强大的功能，但由于性能开销和安全性限制，它应该谨慎使用。在正常情况下，应优先考虑静态类型检查和直接调用方法的方式来编写代码。但在某些特定场景下，反射可以成为弥补静态语言限制的有用工具。

### 实现Java反射的类有什么

在Java中，可以使用以下类来实现反射：

1. **Class类**：它是反射的核心类之一。通过`Class`类可以获取并操作对象的方法、字段、构造函数等信息，还可以创建对象实例。
2. **Field类**：用于描述类的成员变量（字段）。通过`Field`类可以获取和修改字段的值。
3. **Method类**：用于描述类的方法。通过`Method`类可以调用类的方法。
4. **Constructor类**：用于描述类的构造函数。通过`Constructor`类可以创建类的对象。
5. **Modifier类**：用于描述类、字段和方法的修饰符。通过`Modifier`类可以检查和修改修饰符。
6. **Array类**：用于操作数组。通过`Array`类可以动态地创建和访问数组。
7. **Proxy类**：用于动态创建代理类和代理对象。通过`Proxy`类可以实现动态代理。

这些类提供了丰富的API，使得我们可以在运行时获取和操作类的信息，从而实现灵活的编程和框架开发。请注意，这只是Java反射的一小部分，还有其他相关的类和接口可供使用。

### 反射是怎么实现的

Java中的反射是通过`java.lang.reflect`包提供的一组类和接口来实现的。要使用反射，首先需要获取对要操作的类的`Class`对象。有三种常见的方式来获取`Class`对象：

1. 使用类字面常量：`ClassName.class`
2. 调用对象的`getClass()`方法：`object.getClass()`
3. 使用`Class.forName()`方法：`Class.forName("完整类名")`

还有一种可以使用类加载器获取。

一旦获得了`Class`对象，就可以使用它来执行以下操作：

- 创建对象：通过调用`newInstance()`方法来实例化一个类的对象。
- 获取字段信息：使用`getField()`、`getDeclaredField()`等方法获取特定字段的信息，包括名称、类型和修饰符，并可以通过反射机制来读取和设置字段的值。
- 获取方法信息：使用`getMethod()`、`getDeclaredMethod()`等方法获取特定方法的信息，包括名称、参数类型、返回类型和修饰符，并可以通过反射机制来调用方法。
- 调用方法：使用`invoke()`方法来调用特定对象上的方法。
- 动态代理：使用反射可以创建动态代理对象，拦截并处理对目标对象的方法调用。

总结起来，Java中的反射通过`java.lang.reflect`包提供的类和接口实现，允许在运行时动态地检查和操作类、字段、方法等，并提供了灵活性和动态性的好处。

## Class 类

### Class类的作用，生成Class对象的方法有哪些

`java.lang.Class`是反射的入口点之一，它表示一个类或接口的运行时对象。可以通过以下方式获取`Class`对象：

- 使用类名调用静态方法`Class.forName("className")`。
- 使用实例对象的`.getClass()`方法。
- 使用类字面常量`ClassName.class`。
- 使用类加载器。

### Class.forName("全路径") 会调用哪些方法，会调用构造方法吗？加载的类会放在哪？

Class.forName() 会执行执行类构造器<clinit>()方法。

不会调用构造方法

方法区

## 类的加载

### 类加载流程

在Java中，类的加载过程可以分为以下几个步骤：

1. **加载（Loading）**：加载是类加载过程的第一步。它是将类的字节码文件（通常是.class文件）从磁盘或其他存储介质读取到内存中的过程。加载过程由类加载器（ClassLoader）来完成。类加载器根据类的全限定名查找并读取对应的字节码文件，并将其转换成JVM内部可使用的数据结构。
2. **链接（Linking）**：链接是类加载过程的第二步，它包括三个阶段：
   - **验证（Verification）**：验证阶段对字节码进行验证，确保其符合Java虚拟机规范，例如验证字节码的结构、常量池的正确性等。
   - **准备（Preparation）**：准备阶段为类的静态变量（被static修饰的字段）分配内存空间，并设置默认初始值。这些变量会在后续的初始化阶段赋予真正的初始值。
   - **解析（Resolution）**：解析阶段将符号引用（例如字段和方法的引用）转换为直接引用（指向内存地址的指针或句柄），以便在运行时快速访问方法和字段。
3. **初始化（Initialization）**：初始化是类加载过程的最后一步。在初始化阶段，执行类的初始化代码，包括静态变量的赋值和静态代码块的执行。类的初始化是按需进行的，即在首次使用该类时才会触发初始化。初始化过程由虚拟机负责保证线程安全性。

需要注意的是，类的加载过程是延迟加载的，即只有在需要使用某个类时才会加载该类。同时，Java提供了双亲委派模型来管理类加载器之间的关系，确保类的加载具有层次性和一致性。

## 创建对象

### 创建对象的几种方法

![relection_iv_1](/Users/zhangtao/Code/Java/demo/JavaSE/p17_reflection/images/relection_iv_1.png)

### 如何找到对象的实际类

使用对象的 `getClass()` 方法。

### Java反射创建对象效率高还是通过new创建对象的效率高

new 对象创建效率高。

当我们使用`new`关键字创建一个对象时，编译器会在编译时确定对象的类型，并且生成相应的字节码指令来直接创建该类型的对象。这个过程非常高效，不涉及额外的开销。

而当使用反射创建对象时，我们需要通过类名获取对应的`Class`对象，然后再调用`Class`对象的`newInstance()`方法来创建实例。这个过程涉及到了更多的步骤，包括类加载、查找构造函数、权限检查等。这些步骤需要在运行时动态执行，因此会引入一定的性能开销。

另外，使用反射创建对象还存在安全性的考虑。通过反射创建对象可以绕过访问修饰符的限制，即使构造函数是私有的或受保护的，也可以被访问和调用。这可能导致不符合设计意图的对象创建，增加了代码的潜在风险。

因此，除非特殊情况下需要在运行时动态地创建对象，否则建议优先选择直接使用`new`关键字创建对象，以获得更高的效率和更好的代码安全性。

## API 调用

### 如何利用反射机制来访问一个类的方法

1. 通过 Class 的实例调用 `getDeclaredMethod(String methodName,Class ... args)` 获取指定的 Method 实例。
2. Method 实例调用 `setAccessible(true)` 确保此方法是可访问的。
3. Method 实例调用 `invoke(Object obj,Object ... objs)` 实现对 Method 对应的方法的调用。invoke() 的返回值即为Method 对应的方法的返回值，如果 Method 对应的方法的返回值类型为 void，则 invoke() 返回值为 null。

### Java反射获取私有属性，如何改变值

1. 通过 Class 实例调用 `getDeclaredField(String fieldName)`，获取指定的 Field 实例。
2. Field 实例调用 `setAccessible(true)` 确保此属性是可以访问的。
3. Field 实例调用 `get(Object obj)` 或 `set(Object obj,Object value)` 进行获取或设置操作。

针对于核心源码的 api，内部的私有的结构在 jdk17 中就不可以通过反射调用了。